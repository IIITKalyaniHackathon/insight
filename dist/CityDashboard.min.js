(function ( $ ) {
  $.fn.resizable = function ( orientation ) {
    var resizer = $('<div>').addClass('resizer').addClass(orientation+'-resize');
    this.append(resizer).addClass('resizable');

    resizer.on('mousedown',initDrag);

    var startX, startY, startWidth, startHeight;

    var resizable = this;

    function initDrag (e){
      startX = e.clientX;
      startY = e.clientY;
      startWidth = resizable.outerWidth();
      startHeight = resizable.outerHeight();

      $(document).on('mousemove',doDrag);
      $(document).on('mouseup',stopDrag);
    };
  
    var east,south,north,west;
    south = orientation.search("s") >= 0;
    east = orientation.search("e") >= 0;
    north = orientation.search("n") >= 0;
    west = orientation.search("w") >= 0;

    function doDrag (e) {
      if (south)
        resizable.css('height',(startHeight + e.clientY - startY) + 'px');
      if (east)
        resizable.css('width',(startWidth + e.clientX - startX) + 'px');
      if (north)
        resizable.css('top',(e.clientY) + 'px')
                 .css('height',(startHeight + startY - e.clientY) + 'px');
      if (west)
        resizable.css('left',(e.clientX) + 'px')
                 .css('width',(startWidth - e.clientX) + 'px');
    };

    function stopDrag (e){
      $(document).off( 'mousemove', doDrag );
      $(document).off( 'mouseup', stopDrag );
      resizable.trigger('resize');
    };

    this.scroll(function(e){
      resizer.css('top',resizable.scrollTop());
    });

    return this;
  };
  $.fn.setID = function( selector ) {
    if ( selector.charAt(0) === '#' )
      selector = selector.slice(1);
    this.attr( 'id', selector);
    return this;
  };
  $.fn.movable = function () {

    var panel = this.children('.options-panel');
    if ( !panel.length ){
      panel = $('<span>').addClass('options-panel');
      this.prepend(panel);
    }

    var up = $('<span>').addClass('up-button').append('&#x25B2;');
    var down = $('<span>').addClass('down-button').append('&#x25BC;');
    panel.prepend(down);
    panel.prepend(up);

    var _this = this;

    up.on('click',function(){

      _this.insertBefore( _this.prev() );
    
    });

    down.on('click',function(){

      _this.insertAfter(_this.next());
    
    });

    return this;
  };
  $.fn.closable = function( handler ){

    if (!handler) {
      handler = function () {return;};
    }

    var panel = this.children('.options-panel');
    if ( !panel.length ){
      panel = $('<span>').addClass('options-panel');
      this.prepend(panel);
    }

    var close = $('<span>').addClass('close-button').text('X');

    panel.append(close);

    var _this = this;

    close.on('click',function () {
      _this.remove();
      handler();
    });


    return this;
  };
  // $.fn.onUnderflow = function ( fn ) {
  //   var flow = false;
  //   this.on('OverflowEvent' in window ? 'overflowChanged' : 'underflow', function (e) {
  //     if (e.type == 'underflow' ||
  //       ((e.orient == 0 && e.horizontalOverflow == flow) ||
  //         (e.orient == 1 && e.verticalOverflow == flow) ||
  //         (e.orient == 2 && e.horizontalOverflow == flow && e.verticalOverflow == flow))) {
  //       return fn.call(this, e);
  //     }
  //   });
  // };
  // $.fn.noUnderflow = function () {
  //   this.onUnderflow( function () {
  //     this.width(this.parent().innerWidth());
  //   });
  // }
}(jQuery));
var CityDashboard = (function($) {
    "use strict";

    var identifiers = {
        'main' : '#city-dashboard',
        'map' : '#mapWindow',
        'info': '#infoWindow',
        'filters': '#filterBar'
    };

    var properties = {
        'main' : 'mainContainerID',
        'map' : 'mapWindowID',
        'info': 'infoWindowID',
        'filters': 'filterBarID'
    };

    var that = {
        // TODO: This properties must eventually disappear
        mainContainerID: identifiers.main,
        mapWindowID: identifiers.map,
        infoWindowID: identifiers.info,
        filterBarID: identifiers.filters,

        /**
         * Get the data for the dashboard
         *
         * @param {String} uri uri or id for the data source
         * @param {Callback} callback function to pass the data to
         * @param {Object} mapping of properties to pass to the callback
         * @return {Object} result for the callback
         */
        getData: function(uri, callback, props) {
            if (uri.charAt(0) !== '#') {
                $.getJSON(uri, function(json) {
                    props.data = json;

                    // TODO: The return value of callback is never used
                    return callback(props);
                });
            } else {
                return callback(props);
            }
        },

        /**
         * Get/set the id of the dashboard container. The container options are
         * - 'main': main container of the dashboard
         * - 'map': container for the map element
         * - 'info': container information window
         * - 'filters': container for the 'filters bar'
         *
         * @param (String) container for which to get/set the id
         * @param (String) id optional identifier to set for the container
         * @return (String) identifier for the container
         */
        id: function(container, id) {
            if (!(container in identifiers)) throw new Error('The container '+container+' does not exist');
            id = (typeof id === 'undefined') ? identifiers[container] : id;
            that[properties[container]] = identifiers[container] = id;
            return id;
        },

        /**
         * Get a jQuery selector for the dashboard container element.
         *
         * @param (String) container identifier of the container to get
         * @return (jQuery) selector for the container;
         */
        select: function(container) {
            return $(that.id(container));
        }
    };

    return that;
})(jQuery);

CityDashboard.GoogleMap = function ( parameters ) {
	
	// this.observers = [];

  this.center = {
    'lat': parameters.lat || 0,
    'lng': parameters.lng || 0
  };

  this.zoom = parameters.zoom || 12;

  var mapContainer = $(CityDashboard['mapWindowID'])[0];

  this.googlemap = new google.maps.Map( mapContainer, {
    zoom: this.zoom,
    center: new google.maps.LatLng(this.center.lat, this.center.lng),
    disableDefaultUI: true
  });

  $(CityDashboard['mainContainerID'])[0].data = this.googlemap;  
  
};

CityDashboard.GoogleMap.prototype = {

  constructor: CityDashboard.Map

};

CityDashboard.Marker = function( layer_params, attr, map, assoc_layer ){

  this.layer_params = layer_params;
  this.attr =  attr;
  this.map = map;
  this.marker = undefined;
  this.layer = assoc_layer;

};

CityDashboard.Marker.prototype = {

  constructor: CityDashboard.Marker,

  addEvents: function () {
      
    google.maps.event.addListener(this.marker, 'click', triggerEvent);

    var myself = this;

    function triggerEvent() {

      $('#infoWindow').trigger('marker-pressed', {'id': myself.layer.id , 'value': myself.layer_params, 'attr': myself.attr});

      for(var i = 0; i < myself.layer.markers.length; i++) {
        var myMarker = myself.layer.markers[i].marker;
        if (myMarker == this) {
          myMarker.setAnimation(google.maps.Animation.BOUNCE);
        }
        else {
          myMarker.setAnimation(null);
        }
      }

    }

  },

  triggerInitialEvent: function() {},

};

CityDashboard.CircleMarker = function( layer_params, attr, map, assoc_layer ){

  CityDashboard.Marker.call(this, layer_params, attr, map, assoc_layer);

  var myLatlng = new google.maps.LatLng( parseFloat(layer_params.lat), parseFloat(layer_params.lng) );

  var circle = new google.maps.Circle({
      center: myLatlng,
      map: map,
      radius: attr.radius || 400,
      strokeColor: attr.strokeColor || '#FF0000',
      strokeOpacity: attr.strokeOpacity || 0.8,
      strokeWeight: attr.strokeWeight || 2,
      fillColor: attr.fillColor || '#FF0000',
      fillOpacity: attr.fillOpacity || 0.35,
      title: layer_params.landmark || ''
  });

  this.marker = circle;

};

CityDashboard.CircleMarker.prototype = Object.create(CityDashboard.Marker.prototype);

CityDashboard.CircleMarker.prototype = {

  constructor: CityDashboard.CircleMarker,

  addEvents: function () {

    google.maps.event.addListener(this.marker, 'click', triggerEvent);

    var myself = this;

    function triggerEvent() {

      $('#infoWindow').trigger('marker-pressed', {'id': myself.layer.id , 'value': myself.layer_params, 'attr': myself.attr});

    }

  },

  triggerInitialEvent: function() {
    $('#infoWindow').trigger('marker-pressed', {'id': this.layer.id , 'value': this.layer_params, 'attr': this.attr});
  }

};



CityDashboard.ImageMarker = function(layer_params, attr, map, assoc_layer) {

    CityDashboard.Marker.call(this, layer_params, attr, map, assoc_layer);

    var myLatlng = new google.maps.LatLng(parseFloat(layer_params.lat), parseFloat(layer_params.lng));

    var image = {
        // TODO: this relative reference breaks on minify
        url: attr.src || '../src/Layers/Markers/not_found.svg',
        scaledSize: new google.maps.Size(30, 50)
    };

    var imageMarker = new google.maps.Marker({
        position: myLatlng,
        map: map,
        icon: image,
        title: layer_params.landmark || ''
    });

    this.marker = imageMarker;

};

CityDashboard.ImageMarker.prototype = Object.create(CityDashboard.Marker.prototype);

CityDashboard.ImageMarker.prototype = {

    constructor: CityDashboard.ImageMarker,

    addEvents: function() {

        google.maps.event.addListener(this.marker, 'click', triggerEvent);

        var myself = this;

        function triggerEvent() {

            $('#infoWindow').trigger('marker-pressed', {
                'id': myself.layer.id,
                'value': myself.layer_params,
                'attr': myself.attr
            });

            for (var i = 0; i < myself.layer.markers.length; i++) {
                var myMarker = myself.layer.markers[i].marker;
                if (myMarker == this) {
                    myMarker.setAnimation(google.maps.Animation.BOUNCE);
                } else {
                    myMarker.setAnimation(null);
                }
            }

        }

    },

    triggerInitialEvent: function() {
        $('#infoWindow').trigger('marker-pressed', {
            'id': this.layer.id,
            'value': this.layer_params,
            'attr': this.attr
        });
        for (i = 0; i < this.layer.markers.length; i++) {
            this.layer.markers[i].marker.setAnimation(null);
        }
        this.marker.setAnimation(google.maps.Animation.BOUNCE);
    }

};

CityDashboard.SimpleMarker = function( layer_params, attr, map, assoc_layer ){

  CityDashboard.Marker.call(this, layer_params, attr, map, assoc_layer);

  var myLatlng = new google.maps.LatLng( parseFloat(layer_params.lat), parseFloat(layer_params.lng) );

  var marker = new google.maps.Marker({
      position: myLatlng,
      map: map,
      title: layer_params.landmark || ''
  });

  this.marker = marker;

};

CityDashboard.SimpleMarker.prototype = Object.create(CityDashboard.Marker.prototype);

CityDashboard.SimpleMarker.prototype = {

  constructor: CityDashboard.SimpleMarker,

  addEvents: function () {
      
    google.maps.event.addListener(this.marker, 'click', triggerEvent);

    var myself = this;

    function triggerEvent() {

      $('#infoWindow').trigger('marker-pressed', {'id': myself.layer.id , 'value': myself.layer_params, 'attr': myself.attr});

      for(var i = 0; i < myself.layer.markers.length; i++) {
        var myMarker = myself.layer.markers[i].marker;
        if (myMarker == this) {
          myMarker.setAnimation(google.maps.Animation.BOUNCE);
        }
        else {
          myMarker.setAnimation(null);
        }
      }

    }

  },

  triggerInitialEvent: function() {
    $('#infoWindow').trigger('marker-pressed', {'id': this.layer.id , 'value': this.layer_params, 'attr': this.attr});
    for(i = 0; i < this.layer.markers.length; i++) {
      this.layer.markers[i].marker.setAnimation(null);
    }
    this.marker.setAnimation(google.maps.Animation.BOUNCE);
  }

};

CityDashboard.PolylineMarker = function( layer_params, attr, map, assoc_layer ){

  CityDashboard.Marker.call(this, layer_params, attr, map, assoc_layer);

  var myLatlngArray = [];
  var n = layer_params.points.length;

  for(var i = 0; i < n; i++){
    myLatlngArray[i] = new google.maps.LatLng( parseFloat(layer_params.points[i].lat),
                                               parseFloat(layer_params.points[i].lng) );
  }

  var path = new google.maps.Polyline({
    path: myLatlngArray,
    strokeColor: attr.strokeColor || '#000000',
    strokeOpacity: attr.strokeOpacity || 1.0,
    strokeWeight: attr.strokeWeight || 2
  });
  
  path.setMap(map);

};

CityDashboard.PolylineMarker.prototype = Object.create(CityDashboard.Marker.prototype);

CityDashboard.PolylineMarker.prototype = {

  constructor: CityDashboard.PolylineMarker,

  addEvents: function () {},

  triggerInitialEvent: function() {}

};

function MarkerSelector(layer_params, attr, map, assoc_layer) {

    if (attr.type === 'circle')
        return new CityDashboard.CircleMarker(layer_params, attr, map, assoc_layer);

    else if (attr.type === 'image')
        return new CityDashboard.ImageMarker(layer_params, attr, map, assoc_layer);

    else if (attr.type === 'polyline')
        return new CityDashboard.PolylineMarker(layer_params, attr, map, assoc_layer);

    else if (attr.type === 'simple')
        return new CityDashboard.SimpleMarker(layer_params, attr, map, assoc_layer);

}

CityDashboard.Grid = function( layer_params, attr, map, assoc_layer ){

	this.layer_params = layer_params;
	this.attr = attr;
	this.map = map;
	this.layer = assoc_layer;
	this.tiles = []

};

CityDashboard.Grid.prototype = {

  constructor: CityDashboard.Grid,

  build: function() {},

  addEvents: function() {}

};

CityDashboard.HexagonalGrid = function(layer_params, attr, map, assoc_layer) {

    CityDashboard.Grid.call(this, layer_params, attr, map, assoc_layer);

};

CityDashboard.HexagonalGrid.prototype = Object.create(CityDashboard.Grid.prototype);

CityDashboard.HexagonalGrid.prototype = {

    constructor: CityDashboard.HexagonalGrid,

    build: function(mapBounds) {
        // Define loop variables
        var i, j, k;
        //console.log(this.layer_params)

        l = this.attr.size || 0.02;

        var n = this.tiles.length;

        for (i = 0; i < n; i++) {
            this.tiles[i].setMap(null);
        }
        this.tiles = [];

        var zoom = this.map.getZoom();

        var init = l * (Math.pow(2, 12));
        var array = [];
        for (i = 0; i < 22; i++) {
            array.push(init);
            init = init / 2;
        }

        var colorArray = [
            'transparent',
            'blue', // Blue.
            'cyan', // Cyan.
            'green', // Green.
            'yellow', // Yellow.
            'red' // Red.
        ];

        var size = array[zoom];

        var NE = mapBounds.getNorthEast();
        var SW = mapBounds.getSouthWest();

        var h = Math.ceil((3 / 4) * Math.abs(SW.lat() - NE.lat()) / size);
        var w = Math.ceil((5 / 8) * Math.abs(SW.lng() - NE.lng()) / size);

        var v = size * Math.sin(Math.PI / 6);
        var v2 = size * Math.cos(Math.PI / 6);

        for (i = 0; i < h; i++) {
            for (j = 0; j < w; j++) {

                var x = NE.lat() - (size + v) * i;
                var y;
                if (i % 2 === 0)
                    y = NE.lng() - 2 * v2 * j + v2;
                else
                    y = NE.lng() - 2 * v2 * j;

                poly = [{
                    x: x,
                    y: y
                }, {
                    x: x - size,
                    y: y
                }, {
                    x: x - size - v,
                    y: y - v2
                }, {
                    x: x - size,
                    y: y - 2 * v2
                }, {
                    x: x,
                    y: y - 2 * v2
                }, {
                    x: x + v,
                    y: y - v2
                }, {
                    x: x,
                    y: y
                }];

                var myLatlng = [
                    new google.maps.LatLng(poly[0].x, poly[0].y),
                    new google.maps.LatLng(poly[1].x, poly[1].y),
                    new google.maps.LatLng(poly[2].x, poly[2].y),
                    new google.maps.LatLng(poly[3].x, poly[3].y),
                    new google.maps.LatLng(poly[4].x, poly[4].y),
                    new google.maps.LatLng(poly[5].x, poly[5].y),
                    new google.maps.LatLng(poly[6].x, poly[6].y)
                ];

                //data is in hexagon?
                pointsInScreen = [];
                weightsInScreen = [];
                for (k = 0; k < this.layer_params.points.length; k++) {
                    if (mapBounds.contains(new google.maps.LatLng(this.layer_params.points[k].lat,
                            this.layer_params.points[k].lng))) {
                        pointsInScreen.push(this.layer_params.points[k]);
                        weightsInScreen.push(this.layer_params.weights[k]);
                    }
                }
                var fill = 0.0;
                var weight = 1 / weightsInScreen.length;
                var sum = 0;
                for (k = 0; k < weightsInScreen.length; k++) {
                    sum = sum + weightsInScreen[k];
                }
                for (k = 0; k < weightsInScreen.length; k++) {
                    weightsInScreen[k] = weightsInScreen[k] / sum;
                }
                for (k = 0; k < pointsInScreen.length; k++) {
                    if (isPointInPoly(poly, {
                            x: pointsInScreen[k].lat,
                            y: pointsInScreen[k].lng
                        }))
                        fill = fill + weightsInScreen[k];
                }

                var hexagon = new google.maps.Polygon({
                    paths: myLatlng,
                    strokeColor: this.attr.color || '#000000',
                    strokeOpacity: 0.5,
                    strokeWeight: 2,
                    fillColor: colorArray[Math.floor(fill * colorArray.length + 0.5)] || '#000000',
                    fillOpacity: 0.2,
                    geodesic: true
                });

                hexagon.setMap(this.map);

                this.tiles.push(hexagon);

            }
        }

    },

    addEvents: function() {

        var myself = this;

        google.maps.event.addListener(this.map, 'bounds_changed', function() {
            window.setTimeout(myself.build(this.getBounds()), 50);
        });

    }

};

function isPointInPoly(poly, pt) {
    for (var c = false, i = -1, l = poly.length, j = l - 1; ++i < l; j = i)
        ((poly[i].y <= pt.y && pt.y < poly[j].y) || (poly[j].y <= pt.y && pt.y < poly[i].y)) &&
            (pt.x < (poly[j].x - poly[i].x) * (pt.y - poly[i].y) / (poly[j].y - poly[i].y) + poly[i].x) &&
            (c = !c);
    return c;
}

CityDashboard.SquareGrid = function(layer_params, attr, map, assoc_layer) {

    CityDashboard.Grid.call(this, layer_params, attr, map, assoc_layer);

};

CityDashboard.SquareGrid.prototype = Object.create(CityDashboard.Grid.prototype);

CityDashboard.SquareGrid.prototype = {

    constructor: CityDashboard.SquareGrid,

    build: function(mapBounds) {
        var i, j;
        var l = this.attr.size || 0.03;

        var n = this.tiles.length;

        for (i = 0; i < n; i++) {
            this.tiles[i].setMap(null);
        }
        this.tiles = [];

        var zoom = this.map.getZoom();

        var init = l * (Math.pow(2, 12));
        var array = [];
        for (i = 0; i < 22; i++) {
            array.push(init);
            init = init / 2;
        }

        var size = array[zoom];

        var NE = mapBounds.getNorthEast() || 0;
        var SW = mapBounds.getSouthWest() || 0;

        var h = Math.ceil(Math.abs(SW.lat() - NE.lat()) / size);
        var w = Math.ceil(Math.abs(SW.lng() - NE.lng()) / size);

        for (i = 0; i < h; i++) {
            for (j = 0; j < w; j++) {

                var x = NE.lat() - size * i;
                var y = NE.lng() - size * j;

                var myLatlng = [
                    new google.maps.LatLng(x, y),
                    new google.maps.LatLng(x - size, y),
                    new google.maps.LatLng(x - size, y - size),
                    new google.maps.LatLng(x, y - size),
                    new google.maps.LatLng(x, y)
                ];

                var square = new google.maps.Polygon({
                    paths: myLatlng,
                    strokeColor: this.attr.color || '#578b8b',
                    strokeOpacity: 0.5,
                    strokeWeight: 2,
                    fillColor: this.attr.color || '#578b8b',
                    fillOpacity: 0.0,
                    geodesic: true
                });

                square.setMap(this.map);

                this.tiles.push(square);

            }
        }

    },

    addEvents: function() {

        var myself = this;

        google.maps.event.addListener(this.map, 'bounds_changed', function() {
            window.setTimeout(myself.build(this.getBounds()), 50);
        });

    }

};

function GridSelector( layer_params, attr, map, assoc_layer ){

  if ( attr.type === 'square' )
    return new CityDashboard.SquareGrid( layer_params, attr, map, assoc_layer);

  else if ( attr.type === 'hexagonal' )
    return new CityDashboard.HexagonalGrid( layer_params, attr, map, assoc_layer);

}

CityDashboard.Heatmap = function( layer_params, attr, map, assoc_layer ){

};

CityDashboard.Heatmap.prototype = {

  constructor: CityDashboard.Heatmap,

};



CityDashboard.PointHeatmap = function(layer_params, attr, map, assoc_layer) {
    var i;
    var data = [];

    var len = layer_params.points.length;

    if (layer_params.weights && layer_params.weights.length >= len) {
        for (i = 0; i < len; i++) {
            data[i] = {
                location: new google.maps.LatLng(
                    parseFloat(layer_params.points[i].lat),
                    parseFloat(layer_params.points[i].lng)
                ),
                weight: layer_params.weights[i]
            };
        }
    } else {
        for (i = 0; i < len; i++) {
            data[i] = new google.maps.LatLng(
                parseFloat(layer_params.points[i].lat),
                parseFloat(layer_params.points[i].lng)
            );
        }
    }

    var pointArray = new google.maps.MVCArray(data);

    this.heatmap = new google.maps.visualization.HeatmapLayer({
        data: pointArray,
        radius: attr.radius || 10
    });

    this.heatmap.setMap(map);

};

CityDashboard.PointHeatmap.prototype = Object.create(CityDashboard.Heatmap.prototype);

CityDashboard.PointHeatmap.prototype = {

    constructor: CityDashboard.PointHeatmap,

};

CityDashboard.SegmentHeatmap = function(layer_params, attr, map, assoc_layer) {
    var i, j;
    var data = [];

    var n = layer_params.segments.length;

    for (i = 0; i < n; i++) {
        data[i] = [];
        for (j = 0; j < layer_params.segments[i].length; j++) {
            data[i][j] = {
                lat: parseFloat(layer_params.segments[i][j].lat),
                lng: parseFloat(layer_params.segments[i][j].lng)
            };
        }
    }

    var myData = [];

    for (i = 0; i < data.length; i++) {

        var m = data[i].length;

        for (j = 0; j < m - 1; j++) {

            var d = Math.sqrt(Math.pow((data[i][j + 1].lat - data[i][j].lat), 2) + Math.pow((data[i][j + 1].lng - data[i][j].lng), 2));

            //var n = Math.floor(d/0.000005);
            var l = Math.floor(d / 0.00001);

            var delta = {
                lat: (data[i][j + 1].lat - data[i][j].lat) / l,
                lng: (data[i][j + 1].lng - data[i][j].lng) / l
            };

            for (var k = 0; k < l; k++) {

                var lat = data[i][j].lat;
                var lng = data[i][j].lng;
                myData.push({
                    location: new google.maps.LatLng(lat + delta.lat * k, lng + delta.lng * k),
                    weight: layer_params.weights[i] || 1
                });
            }
        }

    }

    this.heatmap = new google.maps.visualization.HeatmapLayer({
        data: myData,
    });

    this.heatmap.setMap(map);

};

CityDashboard.SegmentHeatmap.prototype = Object.create(CityDashboard.Heatmap.prototype);

CityDashboard.SegmentHeatmap.prototype = {

    constructor: CityDashboard.SegmentHeatmap,

};

function HeatmapSelector( layer_params, attr, map, assoc_layer ){

  if ( attr.type === 'point-heatmap' )
    return new CityDashboard.PointHeatmap( layer_params, attr, map, assoc_layer);

  else if ( attr.type === 'segment-heatmap' )
    return new CityDashboard.SegmentHeatmap( layer_params, attr, map, assoc_layer);

}
CityDashboard.DTesselation = function( layer_params, attr, map, assoc_layer ){

	this.layer_params = layer_params;
	this.attr = attr;
	this.map = map;
	this.layer = assoc_layer;

};

CityDashboard.DTesselation.prototype = {

  constructor: CityDashboard.DTesselation,

  build: function () {},

  addEvents: function () {},

  Add_GMapLine: function (StoreArr, Positions, Verts, Color, Thickness, Opacity, map) {

	var rad2deg = 180/Math.PI;
	if (Verts.length < 2) return;
	
	var p0 = Positions[Verts[0]];
	var poss = [p0];
	
	for (var i=1; i<Verts.length; i++)
	{
		var p = Positions[Verts[i]];
		poss = poss.concat(this.SplitSegment(p0,p),[p]);
		p0 = p;
	}
	
	var GLLs = [];
	for (var j=0; j<poss.length; j++)
	{
		var p = poss[j];
		var lat = rad2deg*Math.atan2(p[2],Math.sqrt(p[0]*p[0]+p[1]*p[1]));
		var lng = rad2deg*Math.atan2(p[1],p[0]);
		GLLs.push(new google.maps.LatLng(lat,lng));
	}
	var GPln = new google.maps.Polyline(
	{
		path: GLLs,
		strokeColor: Color,
		strokeWeight: Thickness,
		strokeOpacity: Opacity,
		clickable: false
	});
        GPln.setMap(map);
	StoreArr.push(GPln);
  },

  SplitSegment: function (p0,p1) {

	var diff = 0.0;
	for (var ic=0; ic<3; ic++)
	{
		var dfc = p1[ic] - p0[ic];
		diff += dfc*dfc;
	}
	var empty = [];
	if (diff < 0.01) return empty;
	
	var px = new Array(3);
	for (var ic=0; ic<3; ic++)
		px[ic] = p0[ic] + p1[ic];
	var asqr = 0;
	for (var ic=0; ic<3; ic++)
	{
		pc = px[ic];
		asqr += pc*pc;
	}
	var normmult = 1/Math.sqrt(asqr);
	for (var ic=0; ic<3; ic++)
		px[ic] *= normmult;
	
	return empty.concat(this.SplitSegment(p0,px),[px],this.SplitSegment(px,p1));
  },

  ClearOvlyArray: function (OvlyArray) {
	while (OvlyArray.length > 0)
	{
		var ovly = OvlyArray.pop();
		ovly.setMap(null);
	}
  }

};

CityDashboard.Voronoi = function( layer_params, attr, map, assoc_layer ){

  CityDashboard.DTesselation.call(this, layer_params, attr, map, assoc_layer);

  var data = [];

  var deg2rad = Math.PI/180;
  var rad2deg = 180/Math.PI;

  var MapTriLines = [];
  var MapNgbrLines = [];

  var n = layer_params.points.length;

  for(var i = 0; i < n; i++){
    data[i] = new google.maps.LatLng( parseFloat(layer_params.points[i].lat), parseFloat(layer_params.points[i].lng) );
  }

  var myself = this;

  var PointsChanged = function() {

	myself.ClearOvlyArray(MapNgbrLines);
	
	var MapPositions = [];

	for (var i=0; i<data.length; i++)
	{
		var LatLng = data[i];
		var lat = deg2rad*LatLng.lat();
		var lng = deg2rad*LatLng.lng();
		var lc = Math.cos(lat);
		var pt = [lc*Math.cos(lng), lc*Math.sin(lng), Math.sin(lat)];
		// Add random offset to avoid collinearity
		for (var ic=0; ic<3; ic++)
			pt[ic] += 1e-10 * (2*Math.random() - 1);
		var sumsq = 0;
		for (var ic=0; ic<3; ic++)
			sumsq += pt[ic]*pt[ic];
		var norm = 1/Math.sqrt(sumsq);
		for (var ic=0; ic<3; ic++)
			pt[ic] *= norm;
		// Accept it
		MapPositions.push(pt);
	}
	var DT = FindDelaunayTriangulation(MapPositions);

	for (var i=0; i<DT.vor_edges.length; i++)
	{
		var edge = DT.vor_edges[i];
		if (edge[0] < 0) continue;
		if (edge[1] < 0) continue;
		myself.Add_GMapLine(MapNgbrLines, DT.vor_positions, edge, attr.color || '#578b8b', 2, 1, map);
	}
  }

  PointsChanged();

  markers = [];
  for (var i=0; i< data.length; i++) {
    var marker = new google.maps.Marker({
      position: data[i],
      map: map,
      draggable: true
    });

    markers[i] = marker;
  }

  var f = function() {
      for (var i=0; i< data.length; i++) {
        if(markers[i].position != data[i]){
          data[i] = this.position;
          break;
        }
      }
      PointsChanged();
  };

  for (var i=0; i< data.length; i++) {
    google.maps.event.addListener(markers[i], 'drag', f);
  }

};

CityDashboard.Voronoi.prototype = Object.create(CityDashboard.DTesselation.prototype);

CityDashboard.Voronoi.prototype = {

  constructor: CityDashboard.Voronoi,

  build: function () {},

  addEvents: function () {},

  Add_GMapLine: function (StoreArr, Positions, Verts, Color, Thickness, Opacity, map) {

	var rad2deg = 180/Math.PI;
	if (Verts.length < 2) return;
	
	var p0 = Positions[Verts[0]];
	var poss = [p0];
	
	for (var i=1; i<Verts.length; i++)
	{
		var p = Positions[Verts[i]];
		poss = poss.concat(this.SplitSegment(p0,p),[p]);
		p0 = p;
	}
	
	var GLLs = [];
	for (var j=0; j<poss.length; j++)
	{
		var p = poss[j];
		var lat = rad2deg*Math.atan2(p[2],Math.sqrt(p[0]*p[0]+p[1]*p[1]));
		var lng = rad2deg*Math.atan2(p[1],p[0]);
		GLLs.push(new google.maps.LatLng(lat,lng));
	}
	var GPln = new google.maps.Polyline(
	{
		path: GLLs,
		strokeColor: Color,
		strokeWeight: Thickness,
		strokeOpacity: Opacity,
		clickable: false
	});
        GPln.setMap(map);
	StoreArr.push(GPln);
  },

  SplitSegment: function (p0,p1) {

	var diff = 0.0;
	for (var ic=0; ic<3; ic++)
	{
		var dfc = p1[ic] - p0[ic];
		diff += dfc*dfc;
	}
	var empty = [];
	if (diff < 0.01) return empty;
	
	var px = new Array(3);
	for (var ic=0; ic<3; ic++)
		px[ic] = p0[ic] + p1[ic];
	var asqr = 0;
	for (var ic=0; ic<3; ic++)
	{
		pc = px[ic];
		asqr += pc*pc;
	}
	var normmult = 1/Math.sqrt(asqr);
	for (var ic=0; ic<3; ic++)
		px[ic] *= normmult;
	
	return empty.concat(this.SplitSegment(p0,px),[px],this.SplitSegment(px,p1));
  },

  ClearOvlyArray: function (OvlyArray) {
	while (OvlyArray.length > 0)
	{
		var ovly = OvlyArray.pop();
		ovly.setMap(null);
	}
  }

};
CityDashboard.Delaunay = function( layer_params, attr, map, assoc_layer ){

  CityDashboard.DTesselation.call(this, layer_params, attr, map, assoc_layer);

  var data = [];

  var deg2rad = Math.PI/180;
  var rad2deg = 180/Math.PI;

  var MapTriLines = [];
  var MapNgbrLines = [];

  var n = layer_params.points.length;

  for(var i = 0; i < n; i++){
    data[i] = new google.maps.LatLng( parseFloat(layer_params.points[i].lat), parseFloat(layer_params.points[i].lng) );
  }

  var myself = this;

  var PointsChanged = function() {

	myself.ClearOvlyArray(MapTriLines);
	
	var MapPositions = [];

	for (var i=0; i<data.length; i++)
	{
		var LatLng = data[i];
		var lat = deg2rad*LatLng.lat();
		var lng = deg2rad*LatLng.lng();
		var lc = Math.cos(lat);
		var pt = [lc*Math.cos(lng), lc*Math.sin(lng), Math.sin(lat)];
		// Add random offset to avoid collinearity
		for (var ic=0; ic<3; ic++)
			pt[ic] += 1e-10 * (2*Math.random() - 1);
		var sumsq = 0;
		for (var ic=0; ic<3; ic++)
			sumsq += pt[ic]*pt[ic];
		var norm = 1/Math.sqrt(sumsq);
		for (var ic=0; ic<3; ic++)
			pt[ic] *= norm;
		// Accept it
		MapPositions.push(pt);
	}
	var DT = FindDelaunayTriangulation(MapPositions);
	
	for (var i=0; i<DT.edges.length; i++)
	{
		var edge = DT.edges[i];
		myself.Add_GMapLine(MapTriLines, DT.positions, edge.verts,
			attr.color || '#578b8b', 2, 1, map);
	}
        
  }

  PointsChanged();

  markers = [];
  for (var i=0; i< data.length; i++) {
    var marker = new google.maps.Marker({
      position: data[i],
      map: map,
      draggable: true
    });

    markers[i] = marker;
  }

  var f = function() {
      for (var i=0; i< data.length; i++) {
        if(markers[i].position != data[i]){
          data[i] = this.position;
          break;
        }
      }
      PointsChanged();
  };

  for (var i=0; i< data.length; i++) {
    google.maps.event.addListener(markers[i], 'drag', f);
  }

};

CityDashboard.Delaunay.prototype = Object.create(CityDashboard.DTesselation.prototype);

CityDashboard.Delaunay.prototype = {

  constructor: CityDashboard.Delaunay,

  build: function () {},

  addEvents: function () {},

  Add_GMapLine: function (StoreArr, Positions, Verts, Color, Thickness, Opacity, map) {

	var rad2deg = 180/Math.PI;
	if (Verts.length < 2) return;
	
	var p0 = Positions[Verts[0]];
	var poss = [p0];
	
	for (var i=1; i<Verts.length; i++)
	{
		var p = Positions[Verts[i]];
		poss = poss.concat(this.SplitSegment(p0,p),[p]);
		p0 = p;
	}
	
	var GLLs = [];
	for (var j=0; j<poss.length; j++)
	{
		var p = poss[j];
		var lat = rad2deg*Math.atan2(p[2],Math.sqrt(p[0]*p[0]+p[1]*p[1]));
		var lng = rad2deg*Math.atan2(p[1],p[0]);
		GLLs.push(new google.maps.LatLng(lat,lng));
	}
	var GPln = new google.maps.Polyline(
	{
		path: GLLs,
		strokeColor: Color,
		strokeWeight: Thickness,
		strokeOpacity: Opacity,
		clickable: false
	});
        GPln.setMap(map);
	StoreArr.push(GPln);
  },

  SplitSegment: function (p0,p1) {

	var diff = 0.0;
	for (var ic=0; ic<3; ic++)
	{
		var dfc = p1[ic] - p0[ic];
		diff += dfc*dfc;
	}
	var empty = [];
	if (diff < 0.01) return empty;
	
	var px = new Array(3);
	for (var ic=0; ic<3; ic++)
		px[ic] = p0[ic] + p1[ic];
	var asqr = 0;
	for (var ic=0; ic<3; ic++)
	{
		pc = px[ic];
		asqr += pc*pc;
	}
	var normmult = 1/Math.sqrt(asqr);
	for (var ic=0; ic<3; ic++)
		px[ic] *= normmult;
	
	return empty.concat(this.SplitSegment(p0,px),[px],this.SplitSegment(px,p1));
  },

  ClearOvlyArray: function (OvlyArray) {
	while (OvlyArray.length > 0)
	{
		var ovly = OvlyArray.pop();
		ovly.setMap(null);
	}
  }

};



function DTesselationSelector( layer_params, attr, map, assoc_layer ){

  if ( attr.type === 'delaunay' )
    return new CityDashboard.Delaunay( layer_params, attr, map, assoc_layer);

  else if ( attr.type === 'voronoi' )
    return new CityDashboard.Voronoi( layer_params, attr, map, assoc_layer);

}
CityDashboard.Layer = function( parameters, map ){

  this.wrappedLayer = undefined;

  if ( parameters.id === undefined ){
    throw Error( "All layers must have an ID." )
  }

  this.id = parameters.id;
  this.dataSource = parameters.dataSource;

  this.elements = parameters.data.length ? parameters.data : [ parameters.data ];
  this.elementsAttr = parameters.layer_attr || {'type': 'simple', 'action': 'update' } ;
  this.map = map;

};

CityDashboard.Layer.prototype = {

  constructor: CityDashboard.Layer,

  filter: function ( filterFun ) {},

  clear: function () {},

};

CityDashboard.MarkerLayer = function( parameters , map ){

  CityDashboard.Layer.call(this, parameters, map);
  this.markers = [];

  for (var i = this.elements.length - 1; i >= 0; i--) {
    // asign a marker object to each data package
    var marker = MarkerSelector( this.elements[i], this.elementsAttr, this.map, this );
    this.markers.push(marker);
    marker.addEvents();
  };

  this.markers[0].triggerInitialEvent();

};

CityDashboard.MarkerLayer.prototype = Object.create(CityDashboard.Layer.prototype);

CityDashboard.MarkerLayer.prototype = {

  constructor: CityDashboard.MarkerLayer,

  filter: function ( filterFun ) {
    for(i = 0; i < this.markers.length; i++) {
      if(!filterFun(this.markers[i].layer_params))
        this.markers[i].marker.setVisible(false);
      else
        this.markers[i].marker.setVisible(true);
    }
    for(i = 0; i < this.markers.length; i++) {
      if(this.markers[i].marker.getVisible()) {
        this.markers[i].triggerInitialEvent();
        break;
      }
    }
    
  },

  clear: function() {
    for (var j = 0; j < this.markers.length; j++) {
      this.markers[j].marker.setMap(null);
    };
  }

};

CityDashboard.GridLayer = function( parameters , map ){

  CityDashboard.Layer.call(this, parameters, map);

  this.grid = GridSelector( this.elements[0], this.elementsAttr, this.map, this );
  this.grid.addEvents();

};

CityDashboard.GridLayer.prototype = Object.create(CityDashboard.Layer.prototype);

CityDashboard.GridLayer.prototype = {

  constructor: CityDashboard.GridLayer,

  clear: function() {
    for (var j = 0; j < this.grid.tiles.length; j++) {
      this.grid.tiles[j].setMap(null);
    };
  }

};

CityDashboard.HeatmapLayer = function( parameters , map ){

  CityDashboard.Layer.call(this, parameters, map);

  this.heatmap = new HeatmapSelector( this.elements[0], this.elementsAttr, this.map, this );

};

CityDashboard.HeatmapLayer.prototype = Object.create(CityDashboard.Layer.prototype);

CityDashboard.HeatmapLayer.prototype = {

  constructor: CityDashboard.HeatmapLayer,

  clear: function() {
    this.heatmap.heatmap.setMap(null);
  }

};

CityDashboard.DelaunayLayer = function( parameters , map ){

  CityDashboard.Layer.call(this, parameters, map);

  var DT = DTesselationSelector( this.elements[0], this.elementsAttr, this.map, this );
  DT.addEvents();

};

CityDashboard.DelaunayLayer.prototype = Object.create(CityDashboard.Layer.prototype);

CityDashboard.DelaunayLayer.prototype = {

  constructor: CityDashboard.DelaunayLayer,

  clear: function() {}

};

function LayerSelector( parameters, map ){

  if ( parameters.layer === 'grid-layer' )
    return new CityDashboard.GridLayer( parameters, map );

  else if ( parameters.layer === 'marker-layer' )
    return new CityDashboard.MarkerLayer( parameters, map );

  else if ( parameters.layer === 'heatmap-layer' )
    return new CityDashboard.HeatmapLayer( parameters, map );

  else if ( parameters.layer === 'delaunay-layer' )
    return new CityDashboard.DelaunayLayer( parameters, map );

}
CityDashboard.Visualization = function ( props ) {

var id, data_source, title, properties;
  
  this.id = props['id'];

  this.data_source = props['data-source'] || this.id;

  this.properties = props['properties'] || {};

  this.title = props['title'] || '';

  this.dataPreprocess = props['preprocess'] || function (a) {return a;};

  this.setData( props['data'] || {});

  //placing

  var title = $( '<h4>' ).append(this.title).addClass('viz-title');

  var _this = this;
  this.viz = $('<div>').setID( this.id ).addClass( 'visualization' )
  .append( title )
  .append( $('<hr>').addClass('viz-bar') );

  if (this.properties['closable'] === undefined || this.properties['closable']){
    this.viz.closable(function () {return _this.remove();});
  }
  if (this.properties['movable'] === undefined || this.properties['movable']){
    this.viz.movable();
  }

  this.viz.append( $( '<h6>' ).addClass('latlngView') );

  $( CityDashboard['infoWindowID'] ).append( this.viz );

  this.viz.css( this.properties );

  // checkbox handling

  this.checkbox_handler = props['checkbox-handler'] || function (a,d){return d;};

  if (props.checkbox)
    this.addCheckbox( props['checkbox'] );

};

CityDashboard.Visualization.prototype = {

  constructor: CityDashboard.Visualization,
  setData: function (data) {
    if ( !(data instanceof Array) )
      data =  jQuery.extend({}, data);

    if (!data || Object.keys(data).length === 0)
      this.data = {};
    else
      this.data = this.dataPreprocess(data);
  },
  getData: function () {
    return this.data;
  },
  refresh: function () {
    
    var latlngView = $( this.id ).find('.latlngView').empty();

    this.viz.find('.deflist').remove();

    var data = this.getData();

    var lat = data.lat, lng = data.lng;

    if ( lat && lng)
      latlngView.text('lat: ' + lat + ', lng: ' + lng).insertAfter( $( this.id ).find('hr') );

  },
  remove: function () {
    // signal infowindow to remove this viz.
    $(CityDashboard['infoWindowID']).trigger('remove-viz',{'id':this.id,'data-source':this.data_source});
  },
  createDefList: function ( value ) {
    var id = this.id;
    $.each(value, function (key, value) {

      if (key !== 'lat' && key !== 'lng' && key !=='value') {
        $( id ).find('.deflist').append( $('<dt>').text( key).addClass('deflist-key') )
        .append( $( '<dd>' ).text(value).addClass('deflist-value') );
      }

    });
  },
  addCheckbox: function ( keys ) {
    //keys: {name1:true,name2:false,name3:true,...}
    //each element of the object indicates the label of each checkbox. The number of keys indicates the number of checboxes.
    //handler :  function ([true, false, true, ...],data)
    //each element of the array corresponds to each checkbox state.
    
    var checkpanel = $( "<span>" ).addClass('checkbox-panel');

    var arr = [];

    for (var key in keys) {
      var checkbox = $('<input>').attr('type','checkbox');

      arr[arr.length] = checkbox[0].checked = keys[key];
      checkpanel.append(checkbox);

      var _this = this;

      checkbox.on('change',function () {

        var array = $(this).parent().children('input:checkbox').map(function(){
          return $(this).prop('checked');
        }).get();

        _this.getData = function () {
          var clone  = _this.data;
          if(!(_this.data instanceof Array))
            clone = jQuery.extend({}, _this.data);
          return _this.checkbox_handler(array,clone);
        };

        _this.refresh();

      })

      checkbox.after( $('<label>').text(key) );
    }

    this.viz.append(checkpanel);

    _this.getData = function () {
      var clone  = _this.data;
      if(!(_this.data instanceof Array))
        clone = jQuery.extend({}, _this.data);
      return _this.checkbox_handler(arr,clone);
    };
  }

};
CityDashboard.SummaryVisualization = function ( props ) {

  CityDashboard.Visualization.call( this, props );

  this.viz.addClass('summary-viz');
  this.refresh();
  
}

CityDashboard.SummaryVisualization.prototype = Object.create( CityDashboard.Visualization.prototype );


CityDashboard.SummaryVisualization.prototype.refresh  = function () {

  CityDashboard.Visualization.prototype.refresh.call( this );

  this.viz.append( $('<dl>').addClass('deflist') );

  this.createDefList(this.data);

};


CityDashboard.GeneralVisualization = function ( props ) {
  CityDashboard.Visualization.call( this, props );

  this.viz.addClass('general-viz');

  this.dom = props['dom'];

  this.refresh();
}

CityDashboard.GeneralVisualization.prototype = Object.create( CityDashboard.Visualization.prototype );


CityDashboard.GeneralVisualization.prototype.refresh  = function () {

  CityDashboard.Visualization.prototype.refresh.call( this );

  this.viz.append(this.dom);

  // this.viz.append( $('<dl>').addClass('deflist') );
  // this.createDefList(this.data);

};


CityDashboard.GeneralVisualization.prototype.remove = function () {
  CityDashboard.Visualization.prototype.remove.call( this );
}
CityDashboard.ChartistVisualization = function ( props, chartConstructor ) {

  CityDashboard.Visualization.call( this, props );
  
  this.chartConstructor = chartConstructor;

  this.viz.addClass('chartist-viz').append( $('<div>').addClass(this.properties['class']) );

  this.options = props['options'] || {};

  this.responsiveOptions = props['responsiveOptions'] || {};

  this.labels = props['labels'];

  //checkbox

  // this.checkbox_handler = props['checkbox-handler'] || function (array,data) {
  //       var out = [];
  //       for (var i = 0; i < array.length; i++) {
  //         if (array[i]){
  //           out[out.length] = data[i];
  //         }
  //       };
  //       return out;
  //     };

  this.refresh();
  
};

CityDashboard.ChartistVisualization.prototype = Object.create( CityDashboard.Visualization.prototype );

CityDashboard.ChartistVisualization.prototype.refresh = function () {

  CityDashboard.Visualization.prototype.refresh.call( this );

  var d = this.getData();
  d = d.value || d;

  var data  = {
    'series': d,
    'labels': typeof this.labels === 'function' ? this.labels(d) : this.labels
  };

  if ( this.chart && this.chart.optionsProvider){
    this.chart.update( data );}
  else
    this.chart = new this.chartConstructor( this.id+' > div' , data , this.options, this.responsiveOptions);

  this.viz.append( $('<dl>').addClass('deflist') );

  if (! (this.data instanceof Array))

    this.createDefList(this.data);
};

CityDashboard.ChartistVisualization.prototype.remove = function () {
  CityDashboard.Visualization.prototype.remove.call( this );

  this.chart.detach();
};

CityDashboard.D3Visualization = function ( props ) {
  CityDashboard.Visualization.call( this, props );

  var el = $('<div>');

  this.viz.addClass('d3-viz').append( el );

  var goldenRatio = 0.61803398875;

  var initwidth = el.width();
  var initheight = goldenRatio*initwidth;

  this.svg = d3.select( this.id+' div' ).append('svg');

  if (props['golden-ratio']){
    this._create = function () {

      arguments[1] = arguments[1].value || arguments[1];
      arguments[3] = el.width()*goldenRatio;
      return props.viz.apply(props,arguments);
    }
  } else {
    this._create = function () {
      arguments[3] = initheight;
      arguments[1] = arguments[1].value || arguments[1];
      return props.viz.apply(props,arguments);
    }
  }
  
  //need to call refresh so the lat-lng appears in the first call
  CityDashboard.Visualization.prototype.refresh.call( this );
  this._create(this.svg,this.getData(),initwidth,initheight);

};

CityDashboard.D3Visualization.prototype = Object.create( CityDashboard.Visualization.prototype );

CityDashboard.D3Visualization.prototype.refresh = function () {
  CityDashboard.Visualization.prototype.refresh.call( this );

  this.svg.selectAll("*").remove();

  var data = this.getData();

  var el = $( this.id );
  this._create(this.svg,data,el.width(),el.height());

  this.viz.append( $('<dl>').addClass('deflist') );

  if (! (data instanceof Array))

    this.createDefList(data);
};

CityDashboard.D3Visualization.prototype.remove = function () {
  CityDashboard.Visualization.prototype.remove.call( this );
  
  this.svg.remove();
};
CityDashboard.FilterBar = function(filterNumber) {
    this.filters = {
        none: function(data) {
            return true;
        }
    };
    this.filterNumber = filterNumber;

    this.bar = $('<div>').setID(CityDashboard['filterBarID']).addClass('filterBar');

    /* Google maps geocoder and search bar*/

    var geocoder = new google.maps.Geocoder();

    var geocode = function() {
        var map = $(CityDashboard['mainContainerID'])[0].data;
        var address = $(CityDashboard['filterBarID'] + ' > .search').val();
        geocoder.geocode({
            'address': address
        }, function(results, status) {
            if (status == google.maps.GeocoderStatus.OK) {
                map.setCenter(results[0].geometry.location);
                // map.setZoom(12);
                map.fitBounds(results[0].geometry.bounds);
            } else {
                $(CityDashboard['filterBarID'] + ' > .search').val('not found: ' + address);
            }
        });
    }

    $(CityDashboard['mainContainerID']).append(this.bar);

    this.bar.append($('<input>')
        .addClass('search')
        .attr('type', 'search')
        .attr('placeholder', 'Enter location')
        .on('change', geocode));

    var _this = this;
    this.select = [];

    for (var i = 0; i < this.filterNumber; i++) {
        this.select[i] = $('<select>').on('change', function() {

            $(CityDashboard['mainContainerID']).trigger('filterChanged', function() {
                return _this.composeFilters();
            });

        });
        this.bar.append(this.select[i]);
    }
    this.placeFilters();

};

CityDashboard.FilterBar.prototype = {
    constructor: CityDashboard.FilterBar,
    addFilter: function(filters) {
        for (var key in filters) {
            this.filters[key] = filters[key];
        }
        for (var i = this.select.length - 1; i >= 0; i--) {
            this.select[i].empty();
        };
        this.placeFilters();
    },
    placeFilters: function() {
        var _this = this;
        for (var j = 0; j < this.filterNumber; j++) {
            for (var key in this.filters) {
                var option = $('<option>');

                option.val(function() {
                    return _this.filters[key];
                });
                option.text(key);
                this.select[j].append(option)
            };
        };
    },
    composeFilters: function() {
        var l = [];
        for (var i = this.select.length - 1; i >= 0; i--) {
            l[l.length] = Function('return ' + this.select[i].val())();
        };
        return function(data) {
            for (var i = l.length - 1; i >= 0; i--) {
                if (!l[i](data))
                    return false;
            };
            return true;
        }
    }
}

CityDashboard.InfoWindow = function ( vizPropList ) {

  vizPropList = vizPropList || [];

  this.visualizations = {};
  this.dataSourceTable = {};// better name?

  for (var i = 0; i < vizPropList.length; i++) {
    this.createVisualization( vizPropList[i] );
  };

  //placing

  var infoWindow = $( CityDashboard['infoWindowID'] );

  var _this = this;

  var handler = function ( event, arg ){

    infoWindow.off( 'marker-pressed' );

    if ( arg.attr.id && !(arg.attr.id in _this.visualizations) ) {
      var config = jQuery.extend({}, arg['attr']);
      config['data'] = arg.value;
      config['data-source'] = arg.id;
      // {
      //   'visualization': arg['attr']['visualization'],
      //   'id': arg['attr']['id'],
      //   'data-source': arg['id'],
      //   'data': arg.value,
      //   'preprocess': arg['attr']['preprocess'],
      //   'title': arg['attr']['title'],
      //   'properties': arg['attr']['properties'],
      //   'labels': arg['attr']['labels'],
      //   'checkbox': arg['attr']['checkbox'],
      //   'checkbox-handler': arg['attr']['checkbox-handler'],
      //   'viz': arg['attr']['viz']
      // };

      _this.createVisualization( config );
    }
    
    var vizs = _this.dataSourceTable[ arg.id ] || [];
    for (var i = vizs.length - 1; i >= 0; i--) {
      vizs[i].setData( arg.value );
      vizs[i].refresh();
    };

    infoWindow.on( 'marker-pressed', handler );
  };

  infoWindow.on( 'marker-pressed', handler );

  infoWindow.on( 'resize', function ( e ) {

    for (var key in _this.visualizations) {
      _this.visualizations[key].refresh();
    };

  });

  infoWindow.on( 'remove-viz', function ( e, arg ) {
    delete _this.visualizations[arg.id];
    var index = jQuery.inArray(_this.dataSourceTable[arg['data-source']],arg.id);
    _this.dataSourceTable[arg['data-source']].splice(index,1);
  });

};

CityDashboard.InfoWindow.prototype = {

  constructor: CityDashboard.InfoWindow,

  createVisualization: function ( props ) {

    var _this = this;
    var type = props.visualization;

    var callback = function(pr) {

      var viz;

      if (!type)
        return;

      else if ( type === 'summary-viz' )

        viz = new CityDashboard.SummaryVisualization( pr );

      else if ( type === 'linechart-viz' )

        viz = new CityDashboard.ChartistVisualization( pr, Chartist.Line );

      else if ( type === 'barchart-viz' )

        viz = new CityDashboard.ChartistVisualization( pr, Chartist.Bar );

      else if ( type === 'piechart-viz' )

        viz = new CityDashboard.ChartistVisualization( pr, Chartist.Pie );

      else if ( type === 'd3-viz' )

        viz = new CityDashboard.D3Visualization( pr );

      else if ( type === 'general-viz' )

        viz = new CityDashboard.GeneralVisualization( pr );

      _this.visualizations[viz.id] = viz;
      _this.dataSourceTable[viz.data_source] = _this.dataSourceTable[viz.data_source] || [];
      _this.dataSourceTable[viz.data_source].push(viz);

      return viz;
    }

    return CityDashboard.getData(props['data-source'],callback,props);
  }
};
CityDashboard = CityDashboard || {};

/**
 * Configure the Dashboard of the CityDashboard
 * TODO: explain what is the dashboard as an element
 */
CityDashboard.Dashboard = (function(CityDashboard, $) {
    "use strict";

    /**
     * Constructor for the dashboard
     * TODO: documentation missing
     */
    var Dashboard = function(parameters) {
        this.layers = [];

        if (!parameters.anchor)
            throw new Error('Anchor ID is required.');

        this.anchor = parameters.anchor;

        this.layout = 'layout-' + (parameters.layout || 'none');

        // placing

        var container = $('<div>')
            .setID(CityDashboard.id('main')).addClass('mainDashboard')
            .addClass(this.layout);

        var infoDiv;
        if (this.layout !== 'layout-none') {
            infoDiv = $('<div>')
                .setID(CityDashboard.id('info')).addClass('infoWindow');

            var resizeOrientation;
            if (this.layout === 'layout-left')
                resizeOrientation = 'e';
            else if (this.layout === 'layout-right')
                resizeOrientation = 'w';
            // else if ( this.layout === 'layout-top')
            //   resizeOrientation = 's';
            // else if ( this.layout === 'layout-bottom')
            //   resizeOrientation = 'n';

            infoDiv.resizable(resizeOrientation);

            container.append(infoDiv);
        }

        var mapDiv = $('<div>')
            .setID(CityDashboard.id('map')).addClass('mapWindow');
        container.append(mapDiv);

        $(this.anchor).append(container);

        this.filters = new CityDashboard.FilterBar(parameters['filter-number'] || 0);

        var layers = this.layers;

        container.on('filterChanged', function(e, fun) {
            var f = fun();
            for (var i = layers.length - 1; i >= 0; i--) {
                layers[i].filter(f);
            }
        });

    };

    Dashboard.prototype = {
        constructor: CityDashboard.Dashboard,

        /**
         * TODO: Documentation missing
         */
        addLayer: function(parameters) {

            var layers = this.layers;

            var callback = function(pr) {
                    layers[layers.length] = new LayerSelector(pr, CityDashboard.select('main')[0].data);
                }; // gmap: $(CityDashboard['mainContainerID'])[0].data

            CityDashboard.getData(parameters['data-source'], callback, parameters);

            return this;

        },

        /**
         * TODO: Documentation missing
         */
        addFilter: function(filters) {

            this.filters.addFilter(filters);

            return this;
        },

        /**
         * TODO: documentation missing
         */
        clear: function() {
            for (var i = 0; i < this.layers.length; i++) {
                this.layers[i].clear();
            }
            this.layers = [];
        }
    };

    return Dashboard;
})(CityDashboard, jQuery);
